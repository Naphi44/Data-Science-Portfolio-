# -*- coding: utf-8 -*-
"""Time Series Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BioPLKKwwSNvBsJjlfV8UK0Y4_nussg0

# **Objective**
Develop a robust time‐series forecasting model to accurately predict [e.g. weekly sales/demand] over the next horizon, so that stakeholders can optimize inventory planning, reduce stockouts, and improve overall operational efficiency.
"""

import pandas as pd

df = pd.read_csv('/content/dc.csv') # CSV file available in https://www.kaggle.com/datasets/ahmedadam415/digital-currency-time-series

df = df.rename(columns = {'Unnamed: 0' : 'Time'}) # Rename the Unnamed column to 'Time'
df['Time'] = pd.to_datetime(df['Time']) # Convert the Time into datetime format
df = df.iloc[::-1].set_index('Time')

df.head()

import matplotlib.pyplot as plt
plt.plot(df['close_USD'])
plt.show()

# Split the data
train = df.iloc[:-200] # all rows of the original df except for the last 200 rows.
test = df.iloc[-200:]  # only the last 200 rows of the original df

from statsmodels.tsa.arima.model import ARIMA
# create an instance of the ARIMA model.
model = ARIMA(train['close_USD'], order=(2, 1, 0))
results = model.fit()

# generate future predictions using the fitted model.
forecast = results.forecast(steps=200)
forecast

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

# Calculate and print evaluation metrics for the forecast
mae = mean_absolute_error(test['close_USD'], forecast)
mse = mean_squared_error(test['close_USD'], forecast)
rmse = np.sqrt(mse)
mape = (forecast - test['close_USD']).abs().div(test['close_USD']).mean()

print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")
print(f"MAPE: {mape:.2f}%")

import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, 2, figsize=(15, 5))

# Plot 1: Train, Test, and Forecast
axes[0].plot(train.index, train['close_USD'], label='Train')
axes[0].plot(test.index, test['close_USD'], label='Test')
axes[0].plot(forecast.index, forecast, label='Forecast')
axes[0].legend()
axes[0].set_title('ARIMA Forecast vs Actuals')

# Plot 2: Original 'close_USD' time series
axes[1].plot(df.index, df['close_USD'])
axes[1].set_title('Original Close USD Time Series')

plt.tight_layout()
plt.show()

"""The forecast was worse as our model can’t forecast the increasing trend. The model ARIMA that we use seems too simple for forecasting.

Therefore, it’s better if we use another model outside of statsmodels. Let’s try out the famous prophet package from Facebook. Prophet is a time series forecasting model package that works best on data with seasonal effects.
"""

pip install prophet

df_prophet = df.reset_index()[["Time", "close_USD"]].rename(
    columns={"Time": "ds", "close_USD": "y"}
) # resets the DataFrame's index (which was previously the 'Time' column) back to a default integer index. The 'Time' column is converted back into a regular column.
df_prophet.head()

import pandas as pd
from prophet import Prophet

model = Prophet()
# Fit the model
model.fit(df_prophet)

# create date to predict
future_dates = model.make_future_dataframe(periods=365)

# generates the forecast using the fitted model and the future_dates DataFrame
predictions = model.predict(future_dates)

predictions.head()

model.plot(predictions) # It uses the built-in plotting function of the Prophet model to generate a plot of the forecast. This plot typically shows the actual data points, the forecast line, and the uncertainty intervals around the forecast.
plt.plot(df_prophet['ds'], df_prophet['y'], label='Actual')
plt.plot(predictions['ds'], predictions['yhat'], label='Prophet Forecast')
plt.xlabel('Time')
plt.ylabel('Close USD')
plt.title('Prophet Forecast vs Actuals')
plt.legend()
plt.show()

"""In summary, the above plot visualizes how well the Prophet model's predictions align with the actual historical data."""

model.plot_components(predictions)

"""Prophet includes a diagnostic measurement that we can use: time series cross-validation. The method uses part of the historical data and fits the model each time using data up to the cutoff point. Then the Prophet would compare the predictions with the actual ones. Let’s try using the code."""

from prophet.diagnostics import cross_validation, performance_metrics

# Perform time series cross-validation
# initial: the size of the initial training period
# period: the spacing between cutoff dates
# horizon: the forecast horizon
df_crossval = cross_validation(model, initial='365 days', period='180 days', horizon = '365 days')

# Calculate evaluation metrics from the cross-validation results
result = performance_metrics(df_crossval)

result

import matplotlib.pyplot as plt
from prophet.plot import plot_cross_validation_metric

metrics_to_plot = ['mse', 'rmse', 'mae', 'mape', 'coverage']
# Create a figure with 3 rows and 2 columns for subplots
fig, axes = plt.subplots(3, 2, figsize=(15, 10))
# Flatten the axes array for easy iteration
axes = axes.flatten()

for i, metric in enumerate(metrics_to_plot):
    plot_cross_validation_metric(df_crossval, metric=metric, ax=axes[i])
    axes[i].set_title(f'{metric.upper()} vs. Horizon')

# Hide any unused subplots
for j in range(len(metrics_to_plot), len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""## Notebook Summary and Conclusion

This notebook performs a time series analysis and forecasting of the 'close_USD' data from the provided dataset. The analysis proceeds through the following key stages:

1.  **Data Loading and Preparation**: The dataset is loaded from a CSV file. The 'Unnamed: 0' column, which represents the time information, is renamed to 'Time', converted to a datetime format, and then set as the DataFrame's index. The data is also reversed to ensure it is in chronological order.

2.  **Initial Visualization**: The 'close_USD' time series is plotted to visualize its trend and patterns over time.

3.  **ARIMA Modeling**: An ARIMA model is implemented to forecast the 'close_USD' values.
    *   The data is split into training and testing sets.
    *   An ARIMA model with order (2, 1, 0) is fitted to the training data.
    *   A forecast is generated for the period covered by the testing set.
    *   Evaluation metrics (MAE, RMSE, MAPE) are calculated to assess the ARIMA model's performance.
    *   The ARIMA forecast is visualized against the actual values in the test set, alongside the original time series. The analysis notes that the ARIMA model struggled to capture the increasing trend.

4.  **Prophet Modeling**: Recognizing the limitations of the ARIMA model for this data's trend, the notebook transitions to using the Prophet library, which is well-suited for time series with strong seasonalities.
    *   The data is prepared in the format required by Prophet ('ds' for datestamp and 'y' for the value to be forecasted).
    *   A Prophet model is initialized and fitted to the data.
    *   A forecast is generated for a future period (365 days beyond the historical data).
    *   The Prophet forecast is visualized against the historical data, showing its ability to capture the overall trend and seasonality.
    *   The components of the Prophet model (trend, weekly seasonality, yearly seasonality) are plotted to understand the underlying patterns identified by the model.

5.  **Prophet Cross-Validation**: To evaluate the Prophet model's performance robustly, time series cross-validation is performed.
    *   The `cross_validation` function is used with specified initial training period, period between cutoffs, and forecast horizon.
    *   Performance metrics (mse, rmse, mae, mape, coverage) are calculated from the cross-validation results for different forecast horizons.
    *   These performance metrics are visualized against the forecast horizon to understand how the model's accuracy changes as the prediction window increases.

**Conclusion:**

The notebook successfully demonstrates the application of two different time series forecasting models, ARIMA and Prophet, to the 'close_USD' data. While the initial ARIMA model with sample parameters did not effectively capture the increasing trend, the Prophet model showed promising results in fitting the historical data and forecasting future values, likely due to its ability to handle trends and seasonalities. The cross-validation analysis provides further insight into the Prophet model's performance across different forecast horizons, highlighting how the error metrics generally increase with a longer horizon, which is typical for time series forecasting.

Overall, the notebook provides a good workflow for time series analysis, including data preparation, visualization, modeling, and evaluation using cross-validation. The results suggest that Prophet is a more suitable model than a basic ARIMA for this specific time series, given its clear trend and potential seasonal patterns. Further steps could involve tuning the Prophet model's parameters, adding holidays or extra regressors, and comparing its performance to other advanced time series models.
"""